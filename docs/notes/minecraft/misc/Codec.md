---
title: Codec
createTime: 2025/05/25 07:53:37
permalink: /notes/minecraft/misc/codec/
---

[[TOC]]

## 一、数据驱动的基石

在目前的Minecraft（1.13+）模组开发中，数据驱动已成为主流。无论是自定义生物群系、新的配方类型还是某些复杂的方块行为，我们都倾向于将配置信息存储在 JSON 文件中，而不是硬编码在Java代码里。这极大地提高了模组的灵活性和可配置性。

然而，如何安全、高效地在 JSON 数据和游戏内的 Java 对象之间进行转换呢？这正是 Codec 发挥作用的地方。本文将简单地探讨 Codec 的概念、用途和优势，并结合我的 PortalTransform 模组中的代码进行实例分析。所以有一些不完全正确的地方请指出。

## 二、什么是Codec？

### 2.1 核心概念

Codec（编解码器）这个词在百度百科中的解释是一个能够对一个信号或者一个数据流进行变换的设备或者程序。而我的世界中的 Codec 指的是一个由Mojang开发并深度集成到Minecraft中的双向数据转换框架。

你可以将其简单的理解为一个高度智能化的“翻译官”，它的职责是在两种完全不同的“语言”之间进行精确翻译：

- 语言A： 游戏内存中的 `Java 对象 (Object)`。这是程序逻辑可以直接理解和操作的结构。
- 语言B： 用于存储和传输的`数据格式 (Data Format)`，通常是 `JSON` 或 `NBT`。

`Codec` 的本质是定义一套完整的、双向的映射规则，用来规定一个 `Java` 对象是如何被序列化（保存）为 `Json`，以及一个 `Json` 文件是如何被反序列化（加载）成一个 `Java` 对象。

### 2.2 工作流程

`Codec` 的的工作包含两个方向：

1、编码 / 序列化：

- 方向：`Java 对象` -> 某种 `数据格式 (JSON/NBT)`
- 用途：当你需要将游戏中的一个对象保存到玩家的硬盘（如世界存档）或通过网络发送给客户端时。

2、解码 / 反序列化：

- 方向：某种 `数据格式 (JSON/NBT)` -> `Java 对象`
- 用途：当游戏启动或加载资源时，从数据包的 JSON 文件或世界存档的 NBT 中读取数据，并将其转换为游戏逻辑可以使用的对象。

## 三、为什么我们要使用 Codec？

有些开发者可能会想：“我自己用 GSON 或其他库手动解析JSON不也可以吗？” 答案是可以，但这是一种非常脆弱、低效且容易出错的方式。

### 3.1 如果没有 Codec：手动解析的痛点

想象一下，如果让你手动解析某个`Json`或者`NBT`的数据，你需要编写类似下面这样的伪代码：

假如手动解析[副产物](https://github.com/QiHuang02/PortalTransform/blob/2101-neo/src/main/java/cn/qihuang02/portaltransform/recipe/ItemTransform/Byproducts.java)数据。

你可能需要经历一下步骤：

```txt
1. 检查字段是否存在
2. 检查字段类型是否正确
3. 手动解析嵌套对象
4. 处理可选字段和默认值
5. 调用构造函数
6. 另外，你还需要编写一个 toJson() 方法来执行反向操作！
```

这种方式的缺点显而易见：代码冗长、大量重复的检查、难以维护、并且与Minecraft原版的数据加载/报错系统脱节。

### 3.2 Codec 的核心优势

- 健壮性：`Codec` 自动处理字段缺失、类型错误，并能提供非常清晰的错误日志，指出哪个文件、哪个字段出了问题。
- 代码简洁：将上百行手动解析和序列化的代码，浓缩为几行声明式的定义。逻辑清晰，意图明确。
- 可组合性：你可以像搭积木一样组合 `Codec`。例如，直接复用 `BlockPos.CODEC` 来处理坐标，无需关心其内部实现。
- 可扩展性：可以轻松添加可选字段和默认值。例如，使用 `.optionalFieldOf("field", defaultValue)`。
- 生态集成：`Codec` 是Minecraft数据系统的“一等公民”。使用它意味着你的数据可以被原版的命令重载，享受游戏的数据版本修复（DataFixer）等高级功能。
